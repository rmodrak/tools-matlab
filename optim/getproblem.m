function problem = getproblem(varargin)
%GETPROBLEM Get optimization problem structure.
%   GETPROBLEM(NAME) returns a structure corresponding to one of the named
%   test problems below.
%
%   GETPROBLEM('help') prints help message.
%
%   For more information on the test problems, see "More et al., 1981,
%   Testing Unconstrained Optimization Software, ACM Transcations on
%   Mathematical Software".
%
%   Choose from among the following test problems:
%           Rosenbrock, FreudensteinRoth, PowellBadlyScaled,
%           BrownBadlyScaled, Beale, JennrichSampson, HelicalValley,
%           Bard, Gauss, Meyer, Gulf, Box3D
%

%   Not yet implemented:
%           PowellSingular
%           Wood, KowalikOsborne, BrownDennis, Osborne1, BiggsExp6,
%           Osborne2, Watson, ExtendedRosenbrock, ExtendedPowell,
%           PenaltyfunctionI, PenaltyfunctionII,
%           VariablyDimensionedfunction, Trigonometricfunction
%           BrownAlmostLinear, DiscreteBoundaryValue,
%           DiscreteIntegralEquation, BroydenTridiagonal
%           BroydenBanded, LinearFullRank, LinearRank1
%           LinearRank1Z, Chebyquad

% get input arguments from varargin
if nargin == 0
    name = 'help';

elseif nargin == 1
    name = varargin{1};

elseif nargin == 2
    Func = varargin{1};
    x0 = varargin{2};

else
    error('Too many input arguments.')
end
    
if nargin == 2
    problem.nmod = length(x0);
    problem.Func = Func;
    problem.x0 = x0;

else
    switch name
    case 'help'
        help('getproblem')
    case {
          'Rosenbrock' 'FreudensteinRoth' 'PowellBadlyScaled', ...
          'BrownBadlyScaled' 'Beale' 'JennrichSampson' 'HelicalValley' ...
          'Bard' 'Gauss' 'Meyer' 'Gulf' 'Box3D' 'PowellSingular' ...
          'Wood' 'KowalikOsborne' 'BrownDennis' 'Osborne1' 'BiggsExp6' ...
          'Osborne2' 'Watson' 'ExtendedRosenbrock' 'ExtendedPowell' ...
          'PenaltyfunctionI' 'PenaltyfunctionII' ...
          'VariablyDimensionedfunction' 'Trigonometricfunction' ...
          'BrownAlmostLinear' 'DiscreteBoundaryValue' ...
          'DiscreteIntegralEquation' 'BroydenTridiagonal' ...
          'BroydenBanded' 'LinearFullRank' 'LinearRank1' ...
          'LinearRank1Z' 'Chebyquad'
          }
        problem = feval(name);
    otherwise
        error(badopt(name));
    end
end

% % check if Symbolic Math Toolbox is installed
% try
%     v = ver;
%     any(strcmp('Symbolic Math Toolbox',{v.Name}))
% catch
%     error('Symbolic Math Toolbox must be installed.')
% end


%...........................................................................
function problem = Rosenbrock()

problem = struct( ...
    ...
    'nmod',   2, ...
    ...
    'ndat',   2, ...
    ...
    'Func', @(x) ...
                 ((1-x(1))^2 + 100*(-x(1)^2+x(2))^2), ...
    ...
    'Resd', @(x) [ ...
                 1 - x(1)
                 10*(-x(1)^2+x(2))
                 ], ...
    ...
    'x0',        [ -1.2; 1 ]);
%     'grad', @(x) [ ...
%                  -2*(1-x(1)) - 400*x(1)*(-x(1)^2+x(2))
%                  200*(- x(1)^2+x(2))
%                  ], ...
%     ...
%     'hess', @(x) [ ...
%                  2 + 100*(8*x(1)^2 - 4*(-x(1)^2 + x(2))),  -400*x(1)
%                  -400*x(1),  200
%                  ], ...
%     ...
            
%...........................................................................
function problem = FreudensteinRoth()

problem = struct( ...
    ...
    'nmod',   2, ...
    ...
    'ndat',   2, ...
    ...
    'Func', @(x) ...
                 (-13 + x(1) + ((5-x(2))*x(2)-2)*x(2))^2 + ...
                 (-29 + x(1) + ((x(2)+1)*x(2)-14)*x(2))^2, ...
    ...
    'Resd', @(x) [ ...
                 -13 + x(1) + ((5-x(2))*x(2)-2)*x(2);
                 -29 + x(1) + ((x(2)+1)*x(2)-14)*x(2);
                 ], ...
    ...
    'x0',        [ 0.5; -2 ]);

%...........................................................................
function problem = PowellBadlyScaled()

problem = struct( ...
    ...
    'nmod',   2, ...
    ...
    'ndat',   2, ...
    ...
    'Func', @(x) ...
                 (10^4*x(1)*x(2) - 1)^2 + ...
                 (exp(-x(1)) + exp(-x(2)) - 1.0001)^2, ...
    ...
    'Resd', @(x) [ ...
                 10^4*x(1)*x(2) - 1
                 exp(-x(1)) + exp(-x(2)) - 1.0001
                 ], ...
    ...
    'x0',        [ 0; 1 ]);

%...........................................................................
function problem = BrownBadlyScaled()

problem = struct( ...
    ...
    'nmod',   2, ...
    ...
    'ndat',   3, ...
    ...
    'Func', @(x) ...
                 (x(1) - 10^6)^2 + ...
                 (x(2) - 2*10^-6)^2 + ...
                 (x(1)*x(2) - 2)^2, ...
    ...
    'Resd', @(x) [ ...
                 x(1) - 10^6;
                 x(2) - 2*10^-6
                 x(1)*x(2) - 2
                 ], ...
    ...
    'x0',        [ 1; 1 ]);

%...........................................................................
function problem = Beale()

y1 = 1.5; y2 = 2.25; y3 = 2.625;

problem = struct( ...
    ...
    'nmod',   2, ...
    ...
    'ndat',   3, ...
    ...
    'Func', @(x) ...
                 (y1 - x(1)*(1-x(2)^1))^2 + ...
                 (y2 - x(1)*(1-x(2)^2))^2 + ...
                 (y3 - x(1)*(1-x(2)^3))^2, ...
    ...
    'Resd', @(x) [ ...
                 y1 - x(1)*(1-x(2)^1)
                 y2 - x(1)*(1-x(2)^2)
                 y3 - x(1)*(1-x(2)^3)
                 ], ...
    ...
    'x0',        [ 1; 1 ]);

%...........................................................................
function problem = JennrichSampson()

m = 10;

problem = struct( ...
    ...
    'nmod',   2, ...
    ...
    'ndat',   m, ...
    ...
    'Func', @(x) sum(( ...
                  2 + 2*(1:m) - (exp((1:m)*x(1))+exp((1:m)*x(2))) ...
                  ).^2), ...
    ...
    'Resd', @(x) ...
                 (2 + 2*(1:m) - (exp((1:m)*x(1))+exp((1:m)*x(2)))).', ...
    ...
    'x0',        [ 0.3; 0.4 ]);

%...........................................................................
function problem = HelicalValley()

theta = @(x1,x2) 1/(2*pi)*atan(x2/x1) + 0.5*max(-sign(x1),0);

problem = struct( ...
    ...
    'nmod',   3, ...
    ...
    'ndat',   3, ...
    ...
    'Func', @(x) sum([ ...
                 10*(x(3)-10*theta(x(1),x(2))) ...
                 10*((x(1)^2+x(2)^2)^0.5-1) ...
                 x(3)
                 ].^2), ...
    'Resd', @(x) [ ...
                 10*(x(3)-10*theta(x(1),x(2)))
                 10*((x(1)^2+x(2)^2)^0.5-1)
                 x(3)
                 ], ...
    ...
    'x0',        [ -1; 0; 0 ]);

%...........................................................................
function problem = Bard()

u = (1:15).';

v = 16 - (1:15).';

w = min(u,v);

y = [ 
    0.14
    0.18
    0.22
    0.25
    0.29
    0.32
    0.35
    0.39
    0.37
    0.58
    0.73
    0.96
    1.34
    2.10
    4.39
    ];

problem = struct( ...
    ...
    'nmod',   3, ...
    ...
    'ndat',   15, ...
    ...
    'Func', @(x) sum(( ...
                 y(:) - (x(1) - u(:)./(v(:)*x(2)+w(:)*x(3))) ...
                 ).^2), ...
    ...
    'Resd', @(x) ...
                 y(:) - (x(1) - u(:)./(v(:)*x(2)+w(:)*x(3))), ...
    ...
    'x0',        [ 1; 1; 1 ]);


%...........................................................................
function problem = Gauss()

t = ((8 - (1:15))/2).';

y = [ 
    0.0009
    0.0044
    0.0175
    0.0540
    0.1295
    0.2420
    0.3521
    0.3989
    0.3521
    0.2420
    0.1295
    0.0540
    0.0175
    0.0044
    0.0009
    ];

problem = struct( ...
    ...
    'nmod',   3, ...
    ...
    'ndat',   15, ...
    ...
    'Func', @(x) sum(( ...
                 x(1) * exp((-x(2)*(t(:)-x(3)).^2)/2) - y(:) ...
                 ).^2), ...
    ...
    'Resd', @(x) ...
                 x(1) * exp((-x(2)*(t(:)-x(3)).^2)/2) - y(:), ...
    ...
    'x0',        [ 0.4; 1; 0 ]);

%...........................................................................
function problem = Meyer()

t = (45 + 5*(1:16)).';

y = [
    34780
    28610
    23650
    19630
    16370
    13720
    11540
     9744
     8261
     7030
     6005
     5147
     4427
     3820
     3307
     2872
    ];

problem = struct( ...
    ...
    'nmod',   3, ...
    ...
    'ndat',   16, ...
    ...
    'Func', @(x) sum(( ...
                 x(1)*exp(x(2)./(t(:)+x(3))) - y(:) ).^2), ...
    ...
    'Resd', @(x) ...
                 x(1)*exp(x(2)./(t(:)+x(3))) - y(:), ...
    ...
    'x0',        [ 0.02; 4000; 250 ]);

%...........................................................................
function problem = Gulf()
% More et al.'s statement of problem may be incorrect

m = 10;

t = ((1:m)/m).';

y = 25 + (-50*log(t(:))).^(2/3);

problem = struct( ...
    ...
    'nmod',   3, ...
    ...
    'ndat',   m, ...
    ...
    'Func', @(x) sum(( ...
                 exp( - abs(y(:) - x(2)).^x(3) / x(1) ) - t(:) ).^2), ...
    ...
    'Resd', @(x) ...
                 exp( - abs(y(:).*m.*(1:m).' * x(2)).^x(3) / x(1) ) - t(:), ...
    ...
    'x0',        [ 5; 2.5; 0.15 ]);

%...........................................................................
function problem = Box3D()

m = 10;

t = 0.1*(1:m).';

problem = struct( ...
    ...
    'nmod',   3, ...
    ...
    'ndat',   m, ...
    ...
    'Func', @(x) sum(( ...
                 exp(-t(:)*x(1)) - exp(-t(:)*x(2)) - x(3)*(exp(-t(:))-exp(-10*t(:))) ...
                 ).^2), ...
    ...
    'Resd', @(x) ...
                 exp(-t(:)*x(1)) - exp(-t(:)*x(2)) - x(3)*(exp(-t(:))-exp(-10*t(:))), ...
    ...
    'x0',        [ 0; 10; 20 ]);


%...........................................................................
function problem = PowellSingular()


%...........................................................................
function problem = Wood()


%...........................................................................
function problem = KowalikOsborne()


%...........................................................................
function problem = BrownDennis()


%...........................................................................
function problem = Osborne1()


%...........................................................................
function problem = BiggsExp6()


%...........................................................................
function problem = Osborne2()


%...........................................................................
function problem = Watson()


%...........................................................................
function problem = ExtendedRosenbrock()


%...........................................................................
function problem = ExtendedPowell()


%...........................................................................
function problem = PenaltyfunctionI()


%...........................................................................
function problem = PenaltyfunctionII()


%...........................................................................
function problem = VariablyDimensionedfunction()


%...........................................................................
function problem = Trigonometricfunction()


%...........................................................................
function problem = BrownAlmostLinear()


%...........................................................................
function problem = DiscreteBoundaryValue()


%...........................................................................
function problem = DiscreteIntegralEquation()


%...........................................................................
function problem = BroydenTridiagonal()


%...........................................................................
function problem = BroydenBanded()


%...........................................................................
function problem = LinearFullRank()


%...........................................................................
function problem = LinearRank1()


%...........................................................................
function problem = LinearRank1Z()


%...........................................................................
function problem = Chebyquad()

